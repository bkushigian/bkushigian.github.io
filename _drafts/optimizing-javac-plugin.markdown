---
layout: post
title:  "Building an Optimizing Javac Plugin"
date:   2018-06-02 23:28:50 -0400
categories: java compiler plugin
---

The release of Java 1.8 brought us the Compiler Plugin.  This solves a long
standing problem that was previously solved with a rather ugly hack--using
annotation processors. The Compiler Plugin allows us to get into the innards of
the compiler and update the compilation process.

In what follows I will outline two basic compiler optimizations, one working on
the AST and one working on generated bytecode. Before we begin, let's look at
the first motivating problem.

## The Problem: Right Constant Folding

Listed below is the `TestClass` class and its generated bytecode, which can be
viewed with the command `javap -c TestClass.class`:

{% highlight java %}
public class TestClass { 
  public int addOneTwoArg(int a) {
    return 1 + 2 + a; 
  }
  public int addArgOneTwo(int a) {
    return a + 1 + 2; 
  } 
}
{% endhighlight %}

{% highlight asm %}
Compiled from "TestClass.java" 
public class TestClass { 
  public int addOneTwoArg(int); 
    Code: 
       0: iconst_3 
       1: iload_1 
       2: iadd 
       3: ireturn 
  public int addArgOneTwo(int);
    Code: 
       0: iload_1
       1: iconst_1 
       2: iadd 
       3: iconst_2 
       4: iadd 
       5: ireturn 
}
{% endhighlight %}

An interesting thing is happening here. If we consider the expression 1 + 2 + a
then the Java compiler simplifies it to 3 + a: this optimization is called
constant folding and is a very common compiler optimization. However when we
consider a + 1 + 2, the compiler does not simplify it. Why is that? If you know
anything about ASTs you can probably guess easily enough. In any event, we will
get a minimal example of a compiler plugin up and running that will let us poke
around the AST and figure out why we have this discrepancy.

## Creating a Java Compiler Plugin

Here's the skinny: we want to execute arbitrary code during compilation with
full access to the compiler's innards by running something stupidly simple like
javac --arg-to-run-plugin /class/to/compile. In this section we will get that
set up.

### Project Structure
Here is the basic structure I am using but you can tweak to fit your needs:

```
optimizing-plugin/
    src/
        com/tangentiallyrelated/plugin/
            OptimizationPlugin.java
            OptimizationTaskListener.java
            ConstFoldTreeScanner.java
        META-INF/services/
            com.sun.source.util.Plugin
    resources/classes/
        TestClass.java
```

* Our source code lives in `src/com/tangentiallyrelated/plugin`. 
  * Note the file `src/META-INF/services`. The contents of this will be the
    fully qualified name of your plugin---in my case, that is
    `com.tangentiallyrelated.plugin.OptimizingPlugin`
  * `OptimizationPlugin.java`: this is our plugin (duh) and it is pretty simple
    (see below). All it does is register a task listener to be called back to
    when a compilation phase starts or ends.
  * `OptimizationTaskListener.java`: The task listener waits for the compiler to
    tell it that some sort of compilation event has happened (for example, if
    parsing just finished) and is the entrypoint into our code.
  * `ConstFoldTreeScanner.java`: If you know about compiler design then you know
    that the first phase (lexing/parsing) creates an **abstract syntax tree** or
    AST. A `TreeScanner` is used to traverse the AST and do what needs doin'. 
    Ours will go through and fold any constants that need folding.


### Basic Implementation
We will implement the [`com.sun.tools.util.Plugin`][javac-plugin-docs] interface which specifies two
methods: `getName()` and `init(JavacTask task, String ... args)`. To get this we
have to add a dependency to JDK's `tools.jar`, which in IntelliJ may be done in
ProjectStructure. The sum total responsibility of this `Plugin` is to register a
`TaskListener` with the compiler that will sit there and wait for the right part
of the compilation to begin or end to do its job.

{% highlight java%}

public class OptimizationPlugin implements Plugin {

    @Override
    public String getName() {
        return "OptimizationPlugin";
    }

    @Override
    public void init(JavacTask task, String... args) {
        Context context = ((BasicJavacTask)task).getContext();
        task.addTaskListener(new OptimizationTaskListener(context));
    }
}
{% endhighlight %}

Two notes here. First, we are grabbing a `Context` instance and passing it to our
`TaskListener`. We won't need this until later so just pretend it's not there
for now.  Second, we haven't implemented the `OptimizationTaskListener` yet, so
let's go ahead and do that. If you are unfamiliar with the [Observer
Pattern][observer pattern], read up on it real quick (or don't: basically we
just have a `TaskListener` waiting to be called when interesting stuff happens).

{% highlight java%}
public class OptimizationTaskListener implements TaskListener {
    final Context context;
    public OptimizationTaskListener(Context context) {
        this.context = context;
    }

    @Override
    public void started(TaskEvent e) {}

    @Override
    public void finished(TaskEvent e) {
        if (e.getKind() == TaskEvent.Kind.PARSE){
            // TODO: optimize!
            System.out.println("Task event " + e + " has ended");
        }
    }
}
{% endhighlight %}

Whenever a compilation phase is started the compiler will notify any registered
task listener `t` via `t.started(event)`, where `event` describes which phase is
starting up. Likewise, when a phase finishes `t.ended(event)` is called. At this
point `t` has access to the compilation innards. In our example 
we have interrupted the compiler just after the `PARSE` phase ended. This means
we can make some last minute modifications to the AST:

### Working With ASTs
We now have a basic plugin that can identify which compiler phase just started
or ended; now we build on top of that to update the abstract syntax tree.

We will want to traverse the AST and Java handles this with the
`com.sun.tools.javac.tree.TreeScanner` class. This visits the AST node by node
using the [Visitor Pattern][visitor pattern] and we can override methods to
elicit specific behavior. Below is the listing of the class
`ConstFoldTreeScanner` which we will use to implement constant folding.

{% highlight java %}
public class ConstFoldTreeScanner extends TreeScanner{
    private final Context context;
    public ConstFoldTreeScanner(Context context){
        this.context = context;
    }

    @Override
    public void visitBinary(JCTree.JCBinary tree) {
        System.out.println("visitBinary: " + tree);
        super.visitBinary(tree);
    }
}
{% endhighlight %}

Note that we have overridden the `visitBinary` method which accepts a
`JCTree.JCBinary` node in the AST. We will see why this is in a moment but for
now let's update our TaskListener to call this after the AST has been created.
Change the line `System.out.println("Task event " + e + " has ended");` after
the `TODO: optimize!` above to

{% highlight java %}
    TreeScanner visitor = new ConstFoldTreeScanner(context);
    visitor.scan((JCTree)e.getCompilationUnit);
{% endhighlight %}

Since our visitor only accepts Java Compiler Trees (`JCTree`) we have to
cast our compilation unit which is, in fact, the root node of our AST. We can
now run this with

{% highlight bash %}
$ javac -cp path/to/compiled/code/root -Xplugin:OptimizationPlugin resources/classes/TestClass.java
{% endhighlight %}

Note that our `-cp` flag is used to locate plugin.

On my system it looks like this (output included):

```
ben@bbeonx$ javac -cp out/production/JavaOptimizingCompiler -Xplugin:OptimizationPlugin resources/classes/TestClass.java
visitBinary: 1 + 2 + a
visitBinary: 1 + 2
visitBinary: a + 1 + 2
visitBinary: a + 1
```


## Back To The Problem

### Answering Our Question: Why doesn't right-folding happen?
So now for the question: *Why does `1 + 2 + a` simplify while `a + 1 + 2`
doesn't?* The clue lies in the above output. When the expression `1 + 2 + a` is
parsed it either forms the tree `(+ (+ 1 2) a)` or `(+ 1 (+ 2 a))`: that is, `+`
is either left-associative or right-associative.

We see that `1 + 2 + a` has a sub binary expression `1 + 2` which tells us that
our trees are *left-associative*. Oh, that makes sense! Do you see why? The
compiler can easily figure out that `(+ 1 2)` is the same as `3` and thus can
fold this easily.

Looking at `(+ (+ a 1) 2)` it is clear that the compiler doesn't know how to
simplify subexpression `(+ a 1)` and doesn't think too hard on how to get around
this. Aha! This is why we don't get right constant folding! 

Let's test our hypothesis---create a new method in TestClass:

{% highlight java %}
    public int parenConstantFold(int a) {
        return a + (1 + 2);
    }
{% endhighlight %}

and go ahead and compile it again with your plugin enabled. Actually, let's make
one small modification to our TreeScanner. We are getting a few test methods
going and it will be helpful to have some output telling us which method we are
looking at. In our `ConstFoldTreeScanner`, create the following method:

{% highlight java %}
    @Override
    public void visitMethodDef(JCTree.JCMethodDecl tree) {
        System.out.println("visitMethodDef: " + tree.name);
        super.visitMethodDef(tree);
    }
{% endhighlight %}

Now we recompile with our plugin enabled---on my system I get the following
output:

{% highlight bash %}
ben@bbeonx$ javac -cp out/production/JavaOptimizingCompiler -Xplugin:OptimizationPlugin resources/classes/TestClass.java
visitMethodDef: leftConstantFold
   visitBinary: 1 + 2 + a
   visitBinary: 1 + 2
visitMethodDef: rightConstantFold
   visitBinary: a + 1 + 2
   visitBinary: a + 1
visitMethodDef: parenConstantFold
   visitBinary: a + (1 + 2)
   visitBinary: 1 + 2

{% endhighlight %}

Let's look at the bytecode generated again using `javap -c TestClass`:

```
  public int parenConstantFold(int);
    Code:
       0: iload_1
       1: iconst_3
       2: iadd
       3: ireturn
```

Our added parenthesis have induced a constant fold. Cool!

### So

<!-- git-tag: basic-plugin-working -->



<!-- LINKS -->
[javac-plugin-docs]: https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html
[observer pattern]: https://en.wikipedia.org/wiki/Observer_pattern
[visitor pattern]: https://en.wikipedia.org/wiki/Visitor_pattern
