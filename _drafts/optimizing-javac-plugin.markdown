---
layout: post
title:  "Building an Optimizing Javac Plugin"
date:   2018-06-02 23:28:50 -0400
categories: java compiler plugin
---

The release of Java 1.8 brought us the Compiler Plugin.  This solves a long
standing problem that was previously solved with a rather ugly hack--using
annotation processors. The Compiler Plugin allows us to get into the innards of
the compiler and update the compilation process.

In what follows I will outline two basic compiler optimizations, one working on
the AST and one working on generated bytecode. Before we begin, let's look at
the first motivating problem.

## The Problem: Right Constant Folding

Listed below is the `TestClass` class and its generated bytecode, which can be
viewed with the command `javap -c TestClass.class`:

{% highlight java %}
public class TestClass { 
  public int addOneTwoArg(int a) {
    return 1 + 2 + a; 
  }
  public int addArgOneTwo(int a) {
    return a + 1 + 2; 
  } 
}
{% endhighlight %}

{% highlight asm %}
Compiled from "TestClass.java" 
public class TestClass { 
  public int addOneTwoArg(int); 
    Code: 
       0: iconst_3 
       1: iload_1 
       2: iadd 
       3: ireturn 
  public int addArgOneTwo(int);
    Code: 
       0: iload_1
       1: iconst_1 
       2: iadd 
       3: iconst_2 
       4: iadd 
       5: ireturn 
}
{% endhighlight %}

An interesting thing is happening here. If we consider the expression `1 + 2 +
a` then the Java compiler simplifies it to `3 + a`: this optimization is called
*constant folding* and is a very common compiler optimization. However when we
consider `a + 1 + 2`, the compiler does not simplify it. Why is that? If you
know anything about ASTs you can probably guess easily enough. In any event, we
will get a minimal example of a compiler plugin up and running that will let us
poke around the AST and figure out why we have this discrepancy.

## Creating a Java Compiler Plugin

Here's the skinny: we want to execute arbitrary code during compilation with
full access to the compiler's innards by running something stupidly simple like
`javac --use-plugin class/to/compile`. In this section we will get that
set up.

### Project Structure
Here is the basic structure I am using but you can tweak to fit your needs:

```
optimizing-plugin/
    src/
        com/tangentiallyrelated/plugin/
            OptimizationPlugin.java
            OptimizationTaskListener.java
            ConstFoldTreeScanner.java
        META-INF/services/
            com.sun.source.util.Plugin
    resources/classes/
        TestClass.java
```

* Our source code lives in `src/com/tangentiallyrelated/plugin`. 
  - Note the file `src/META-INF/services`. The contents of this will be the
    fully qualified name of your plugin---in my case, that is
    `com.tangentiallyrelated.plugin.OptimizingPlugin`
  - `OptimizationPlugin.java`: this is our plugin (duh) and it is pretty simple
    (see below). All it does is register a task listener to be called back to
    when a compilation phase starts or ends.
  - `OptimizationTaskListener.java`: The task listener waits for the compiler to
    tell it that some sort of compilation event has happened (for example, if
    parsing just finished) and is the entrypoint into our code. Basically, just
    the [Observer Pattern][observer pattern]
  - `ConstFoldTreeScanner.java`: If you know about compiler design then you know
    that the first phase (lexing/parsing) creates an *abstract syntax tree*
    (AST). A `TreeScanner` is used to traverse the AST and do what needs doing.
    Ours will go through and fold any constants that need folding.


### Basic Implementation
We will implement the [`com.sun.tools.util.Plugin`][javac-plugin-docs] interface
which specifies two methods: `getName()` and `init(JavacTask task, String ...
args)`. To get this we have to add a dependency to JDK's `tools.jar`. The sum
total responsibility of this plugin is to register a TaskListener with the
compiler that will sit there and wait for the right part of the compilation to
begin or end to do its job. In this section we will do just enough to test that
we are getting compilation information from the compiler.

{% highlight java%}

public class OptimizationPlugin implements Plugin {

    @Override
    public String getName() {
        return "OptimizationPlugin";
    }

    @Override
    public void init(JavacTask task, String... args) {
        Context context = ((BasicJavacTask)task).getContext();
        task.addTaskListener(new OptimizationTaskListener(context));
    }
}
{% endhighlight %}

A few notes: 
* First, double check `getName()`---this has to return the same name as what you
  specify via command line (more below).
* Second, we are grabbing a `Context` instance and passing it to our
  `TaskListener`. We won't need this until later so just pretend it's not there
  for now.  
* We haven't implemented the `OptimizationTaskListener` yet, so let's go ahead
  and do that now.

{% highlight java%}
public class OptimizationTaskListener implements TaskListener {
    final Context context;
    public OptimizationTaskListener(Context context) {
        this.context = context;
    }

    @Override
    public void started(TaskEvent e) {}

    @Override
    public void finished(TaskEvent e) {
        if (e.getKind() == TaskEvent.Kind.PARSE){
            // TODO: optimize!
            System.out.println("Task event " + e + " has ended");
        }
    }
}
{% endhighlight %}

Whenever a compilation phase is started the compiler will notify any registered
task listener `t` via `t.started(event)`, where `event` describes which phase is
starting up. Likewise, when a phase finishes `t.ended(event)` is called. At this
point `t` has access to the compilation innards via the `event` argument that is
passed in. In our example we have interrupted the compiler just after the
`PARSE` phase ended. This means we can make some last minute modifications to
the AST. But first, let's ensure that this is working properly.


### Building and Running

Go ahead and build your project. From our root directory we can invoke the
`javac` CLI with

```
javac -cp path/to/compiled/files -Xplugin:OptimizationPlugin resources/classes/TestClass.java
```

If you are using an IDE then your classpath will be something along the lines of
`out/production/project-name` (this is where mine is); otherwise, if you are
outputting class files where your source files are you can just set classpath as
`src`.

### Working With ASTs
We now have a basic plugin that can identify which compiler phase just started
or ended; now we build on top of that to update the abstract syntax tree.

We will want to traverse the AST and Java handles this with the
`com.sun.tools.javac.tree.TreeScanner` class. This visits the AST node by node
using the [Visitor Pattern][visitor pattern] and we can override methods to
elicit specific behavior. Below is the listing of the class
`ConstFoldTreeScanner` which we will use to implement constant folding.

{% highlight java %}
public class ConstFoldTreeScanner extends TreeScanner{
    private final Context context;
    public ConstFoldTreeScanner(Context context){
        this.context = context;
    }

    @Override
    public void visitBinary(JCTree.JCBinary tree) {
        System.out.println("visitBinary: " + tree);
        super.visitBinary(tree);
    }
}
{% endhighlight %}

Note that we have overridden the `visitBinary` method which accepts a
`JCTree.JCBinary` node in the AST. We will see why this is in a moment but for
now let's update our TaskListener to call this after the AST has been created.
Change the line `System.out.println("Task event " + e + " has ended");` after
the `TODO: optimize!` above to

{% highlight java %}
    TreeScanner visitor = new ConstFoldTreeScanner(context);
    visitor.scan((JCTree)e.getCompilationUnit);
{% endhighlight %}

Since our visitor only accepts Java Compiler Trees (`JCTree`) we have to
cast our compilation unit which is, in fact, the root node of our AST. We can
now run this with

{% highlight bash %}
$ javac -cp path/to/compiled/code/root -Xplugin:OptimizationPlugin resources/classes/TestClass.java
{% endhighlight %}

Note that our `-cp` flag is used to locate plugin.

On my system it looks like this (output included):

```
ben@bbeonx$ javac -cp out/production/JavaOptimizingCompiler -Xplugin:OptimizationPlugin resources/classes/TestClass.java
visitBinary: 1 + 2 + a
visitBinary: 1 + 2
visitBinary: a + 1 + 2
visitBinary: a + 1
```


## Back To The Problem

### Answering Our Question: Why doesn't right-folding happen?
So now for the question: *Why does `1 + 2 + a` simplify while `a + 1 + 2`
doesn't?* The clue lies in the above output. When the expression `1 + 2 + a` is
parsed it either forms the tree `(+ (+ 1 2) a)` or `(+ 1 (+ 2 a))`: that is, `+`
is either left-associative or right-associative.

We see that `1 + 2 + a` has a sub binary expression `1 + 2` which tells us that
our trees are *left-associative*. Oh, that makes sense! Do you see why? The
compiler can easily figure out that `(+ 1 2)` is the same as `3` and thus can
fold this easily.

Looking at `(+ (+ a 1) 2)` it is clear that the compiler doesn't know how to
simplify subexpression `(+ a 1)` and doesn't think too hard on how to get around
this. Aha! This is why we don't get right constant folding! 

Let's test our hypothesis---create a new method in TestClass:

{% highlight java %}
    public int parenConstantFold(int a) {
        return a + (1 + 2);
    }
{% endhighlight %}

and go ahead and compile it again with your plugin enabled. Actually, let's make
one small modification to our TreeScanner. We are getting a few test methods
going and it will be helpful to have some output telling us which method we are
looking at. In our `ConstFoldTreeScanner`, create the following method:

{% highlight java %}
    @Override
    public void visitMethodDef(JCTree.JCMethodDecl tree) {
        System.out.println("visitMethodDef: " + tree.name);
        super.visitMethodDef(tree);
    }
{% endhighlight %}

Now we recompile with our plugin enabled---on my system I get the following
output:

{% highlight bash %}
ben@bbeonx$ javac -cp out/production/JavaOptimizingCompiler -Xplugin:OptimizationPlugin resources/classes/TestClass.java
visitMethodDef: leftConstantFold
   visitBinary: 1 + 2 + a
   visitBinary: 1 + 2
visitMethodDef: rightConstantFold
   visitBinary: a + 1 + 2
   visitBinary: a + 1
visitMethodDef: parenConstantFold
   visitBinary: a + (1 + 2)
   visitBinary: 1 + 2
{% endhighlight %}

Let's look at the bytecode generated again using `javap -c TestClass`:

```
  public int parenConstantFold(int);
    Code:
       0: iload_1
       1: iconst_3
       2: iadd
       3: ireturn
```

Our added parenthesis have induced a constant fold. Cool!

### Implementing Right Constant Folding

Consider the following expression:

{% highlight java %}
int yearsToSeconds(int years){
  int seconds = years * 60 * 60 * 24 * 365;
  return seconds;
}
{% endhighlight %}

In fact, lets add this to our `TestClass.java` file since this will demonstrate
another optimization that we will be performing later. We compile with our
plugin which outputs

```
visitMethodDef: yearsToSeconds
   visitBinary: years * 60 * 60 * 24 * 365
   visitBinary: years * 60 * 60 * 24
   visitBinary: years * 60 * 60
   visitBinary: years * 60
```

Thus the innermost binary node in our expression is `(* years 60)`, and its
parent is `(* (* years 60) 60)`, etc. This means we have an AST of the form

{% highlight clojure %}
  (* (* (* (* years 60) 60) 24) 
     365)
{% endhighlight %}

The root node has the literal `356` for its right branch and its left branch has
the literal `24` for *its* right branch. In particular, we have
an expression tree of the form

{% highlight clojure %}
  (op (op SUBTREE LITERAL) LITERAL) 
{% endhighlight %}

and since we are working with a nice operator (multiplication) we can replace
the above tree with

{% highlight clojure %}
  (op SUBTREE (op LITERAL LITERAL))
{% endhighlight %}

where `(op LITERAL LITERAL)` is evaluated and folded. 

A word of warning: we have to be careful that we don't change the semantics of
the program, which means that we need to respect *associativity* and
*commutativity*: 

* `(/ (/ 100 10) 2)` is not the same as `(/ 100 (/10 2))` because *division
  isn't associative*;
* `(* (+ a b) c)` is different from `(* a (+ b c))` *because `*` doesn't commute
  with `+`*.

Another way to think about this is that we are *rotating* our parse tree while
preserving semantics. So if we have a tree
```
                  +
                 / \
                +   1
               / \ 
              +   2
             / \ 
            a   3
```

we want to produce the AST

```
              +
             / \ 
            a   +
               / \ 
              3   +
                 / \ 
                2   1
```

which can easily be replaced by the tree by recursively evaluating our
right-leaning expression `(+ 3 (+ 2 1))`:

```
              +
             / \ 
            a   6
```

Alright, so we should create a class that updates a binary operator tree node if
it can be folded. We will call this class `TreeFolder` because we are not very
creative. There is a bit of work to be done here so I'll give the listing
followed by an explanation of what everything does.

{% highlight java %}
public class TreeFolder {

    /**
     * For ease of use, lookup table for operators
     */
    private static HashMap<JCTree.Tag, BiFunction<JCTree.JCLiteral, JCTree.JCLiteral, JCTree.JCLiteral>> interpreters;

    static {
        interpreters = new HashMap<>();
        interpreters.put(JCTree.Tag.PLUS,
                (l, r) -> createIntLiteral(((Integer)l.getValue()) + ((Integer)r.getValue())));
        interpreters.put(JCTree.Tag.MUL,
                (l, r) -> createIntLiteral(((Integer)l.getValue()) * ((Integer)r.getValue())));
    }

    /**
     * Create a new JCTree.JCLiteral with value {@code value}
     * @param value
     * @return
     */
    private static JCTree.JCLiteral createIntLiteral(int value){
        try {
            Constructor<JCTree.JCLiteral> constructor;
            constructor = JCTree.JCLiteral.class.getDeclaredConstructor(TypeTag.class, Object.class);
            constructor.setAccessible(true);
            return constructor.newInstance(TypeTag.INT, value);
        } catch (NoSuchMethodException
                | InstantiationException
                | IllegalAccessException
                | InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }


    /**
     * Test if the operator is associative---here operators are specified with
     * the {@code JCTree.Tag} type.
     * @param tag
     * @return
     */
    private static boolean tagIsAssociative(JCTree.Tag tag){
        switch (tag){
            case PLUS:
            case MUL:
                return true;
            default:
                return false;
        }
    }

    /**
     * Test if this is right foldable
     * @param tree AST node to test
     * @return {@code true} if we can bold this and {@code false} otherwise
     */
    private static boolean isRightFoldable(JCTree.JCBinary tree){
        final JCTree.Tag tag = tree.getTag();
        final JCTree.JCExpression lhs = tree.lhs;
        final JCTree.JCExpression rhs = tree.rhs;
        return tagIsAssociative(tag) && interpreters.containsKey(tag)
                                     && rhs instanceof JCTree.JCLiteral
                                     && lhs instanceof JCTree.JCBinary
                                     && ((JCTree.JCLiteral)((JCTree.JCBinary)lhs).rhs).typetag == TypeTag.INT
                                     && ((JCTree.JCLiteral) rhs).typetag == TypeTag.INT;
    }

    /**
     * Perform a right constant fold if possible, otherwise do nothing
     * @param tree
     */
    static void foldr(JCTree.JCBinary tree){

        if (isRightFoldable(tree))
        {
            final JCTree.Tag tag = tree.getTag();
            final JCTree.JCBinary lhs = (JCTree.JCBinary)tree.lhs;
            final JCTree.JCLiteral rhs = (JCTree.JCLiteral)tree.rhs;
            final BiFunction<JCTree.JCLiteral, JCTree.JCLiteral, JCTree.JCLiteral> fn = interpreters.get(tag);

            if (lhs.getTag() == tag && lhs.rhs instanceof JCTree.JCLiteral){
                final JCTree.JCLiteral lrLit = (JCTree.JCLiteral)lhs.rhs;
                final JCTree.JCExpression llExpr = lhs.lhs;
                final JCTree.JCLiteral newLiteral = fn.apply(lrLit, rhs);
                if (newLiteral == null){
                   return;
                }
                tree.lhs = llExpr;
                tree.rhs = newLiteral;
            }
        }
    }
}
{% endhighlight %}




<!-- git-tag: basic-plugin-working -->



<!-- LINKS -->
[javac-plugin-docs]: https://docs.oracle.com/javase/8/docs/jdk/api/javac/tree/com/sun/source/util/Plugin.html
[observer pattern]: https://en.wikipedia.org/wiki/Observer_pattern
[visitor pattern]: https://en.wikipedia.org/wiki/Visitor_pattern
