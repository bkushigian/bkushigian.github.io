---
layout: post
title:  "Building an Optimizing Javac Plugin"
date:   2018-06-02 23:28:50 -0400
categories: java compiler plugin
---

The release of Java 1.8 brought us the Compiler Plugin.  This solves a long
standing problem that was previously solved with a rather ugly hack--using
annotation processors. The Compiler Plugin allows us to get into the innards of
the compiler and update the compilation process.

In what follows I will outline two basic compiler optimizations, one working on
the AST and one working on generated bytecode. Before we begin, let's look at
the first motivating problem.

## The Problem: Right Constant Folding

Listed below is the `TestClass` class and its generated bytecode, which can be
viewed with the command `javap -c TestClass.class`:

{% highlight java %}
public class TestClass { 
  public int addOneTwoArg(int a) {
    return 1 + 2 + a; 
  }
  public int addArgOneTwo(int a) {
    return a + 1 + 2; 
  } 
}
{% endhighlight %}

{% highlight asm %}
Compiled from "TestClass.java" 
public class TestClass { 
  public int addOneTwoArg(int); 
    Code: 
       0: iconst_3 
       1: iload_1 
       2: iadd 
       3: ireturn 
  public int addArgOneTwo(int);
    Code: 
       0: iload_1
       1: iconst_1 
       2: iadd 
       3: iconst_2 
       4: iadd 
       5: ireturn 
}
{% endhighlight %}

An interesting thing is happening here. If we consider the expression 1 + 2 + a
then the Java compiler simplifies it to 3 + a: this optimization is called
constant folding and is a very common compiler optimization. However when we
consider a + 1 + 2, the compiler does not simplify it. Why is that? If you know
anything about ASTs you can probably guess easily enough. In any event, we will
get a minimal example of a compiler plugin up and running that will let us poke
around the AST and figure out why we have this discrepancy.

## Creating a Java Compiler Plugin

Here's the skinny: we want to execute arbitrary code during compilation with
full access to the compilers innards by running something stupidly simple like
javac --arg-to-run-plugin /class/to/compile. In this section we will get that
set up.

First, a note about our project structure. Here is the basic structure I am
using but you can tweak to fit your needs:

```
optimizing-plugin/
    src/
        com/tangentiallyrelated/plugin/
            *.java
        META-INF/services/
            com.sun.source.util.Plugin
    resources/classes/
        TestClass.class
```

Our source code lives in src/com/tangentiallyrelated/plugin, and note the file src/META-INF/services. The contents of this will be the fully qualified name of your plugin---in my case, that is com.

We will implement the com.sun.tools.util.Plugin interface which specifies two methods: getName() and init(JavacTask task, String ... args). To get this we have to add a dependency to JDK's tools.jar, which in IntelliJ may be done in ProjectStructure. The sum total responsibility of this Plugin is to register a TaskListener with the compiler that will sit there and wait for the right part of the compilation to kick in and do its dirty work.

{% highlight java%}
/**
 * A Compiler Plugin to perform optimizations on the Java compilation
 * process.
 */
public class OptimizationPlugin implements Plugin {

    @Override
    public String getName() {
        return "OptimizationPlugin";
    }

    @Override
    public void init(JavacTask task, String... args) {
        Context context = ((BasicJavacTask)task).getContext();
        task.addTaskListener(new OptimizationTaskListener()); // TODO
    }
}
{% endhighlight %}

Two notes here. First, we are grabbing a Context instance and passing it to our TaskListener. We will want this later so just pretend it's not there for now. Second, we haven't implemented the OptimizationTaskListener yet, so let's go ahead and do that. If you are unfamiliar with the Observer Pattern, read up on it real quick (or don't: basically we just have a TaskListener waiting to be called when interesting stuff happens).

{% highlight java%}
public class OptimizationTaskListener implements TaskListener {

    @Override
    public void started(TaskEvent e) {}

    @Override
    public void finished(TaskEvent e) {
        if (e.getKind() == TaskEvent.Kind.PARSE){
            // TODO: optimize!
        }
    }
}
{% endhighlight %}
